{"title":"JSON HAL","slug":"json-hal","published":"2016-05-02","version":1,"html":"<h1>JSON HAL<\/h1>\n<p>Some years ago there was SOAP. It was bloated and confusing. Both the responses and requests where huge piles of crappy XML. So somebody thought &quot;let's use the HTTP the way it's meant to be used&quot;. And then REST appeared and everyone was happy. REST is different from SOAP, as it's oriented on resources, when SOAP is oriented on RPC. But SOAP had one big advantage. All the methods where defined in a WSDL. In REST the client just had to know what the possible methods, and links between the resources are. It also had to figure out how to identify a resource is linked to another one.\nE.g. let's take a look at a <code>\/users\/agares<\/code> resource:<\/p>\n<pre><code class=\"language-json\">{\n\t&quot;nickname&quot;: &quot;agares&quot;,\n\t&quot;blog_ids&quot;: [32, 76, 45],\n\t&quot;articles&quot;: [&quot;some-article-slug&quot;, &quot;some-other-article-slug&quot;]\n}\n<\/code><\/pre>\n<p>From this we know that &quot;agares&quot; owns blogs with ids 32, 76 and 45. But how do we find them? <code>\/users\/agares\/blogs\/{id}<\/code>? <code>\/blogs\/{id}<\/code>? Or maybe the resource is really called journal (<code>\/journals\/{id}<\/code>)? Oh, and we've forgotten to mention on which blogs are the articles available, so let's fix the resource:<\/p>\n<pre><code class=\"language-json\">{\n\t&quot;nickname&quot;: &quot;agares&quot;,\n\t&quot;blog_ids&quot;: [32, 76, 45],\n\t&quot;articles&quot;: [\n\t\t{&quot;blog_id&quot;: 32, &quot;slug&quot;: &quot;some-article-slug&quot;}, \n\t\t{&quot;blog_id&quot;: 76, &quot;slug&quot;: &quot;some-other-article-slug&quot;}\n\t]\n}\n<\/code><\/pre>\n<p>Okay, now, if we have API's documentation, we probably have enough information to access the articles. But do we really care about the ID's of the articles or blogs? How often do you see a bussines need to expose ID's? Probably not too often. What we really need is a way to access the articles and the blogs. And to do that, all we need is an url. So let's try replacing the useless references with links:<\/p>\n<pre><code class=\"language-json\">{\n\t&quot;nickname&quot;: &quot;agares&quot;,\n\t&quot;_links&quot;: {\n\t\t&quot;blogs&quot;: [\n\t\t\t{ &quot;href&quot;: &quot;\/blogs\/32&quot; },\n\t\t\t{ &quot;href&quot;: &quot;\/blogs\/76&quot; },\n\t\t\t{ &quot;href&quot;: &quot;\/blogs\/45&quot; }\n\t\t],\n\t\t&quot;articles&quot;: [\n\t\t\t{ &quot;href&quot;: &quot;\/blogs\/32\/articles\/some-article-slug&quot; },\n\t\t\t{ &quot;href&quot;: &quot;\/blogs\/76\/articles\/some-other-article-slug&quot; }\n\t\t]\n\t}\n}\n<\/code><\/pre>\n<p>Now, without consulting the documentation, we know where to look for the linked resources. And hey, that resource is a valid JSON HAL document.\nBut of course, as it usually is in life, when you fix something, you break something. When someone asks for &quot;\/blogs\/32&quot;, they get a resource describing particular blog, with links to the articles. So, to show a page with 10 articles, we need 11 requests. Well, that's far from perfect. But the people who created the <a href=\"https:\/\/tools.ietf.org\/html\/draft-kelly-json-hal-07\">JSON HAL specification<\/a> (it's a draft actually, but who cares?) have thought about that. The answer to our problem is called &quot;embedded resources&quot;. As the spec says: &quot;Embedded Resources MAY be a full, partial, or inconsistent version of the representation served from the target URI.&quot;. So, let's create a <strong>blog<\/strong> resource:<\/p>\n<pre><code class=\"language-json\">{\n\t&quot;id&quot;: 32,\n\t&quot;title&quot;: &quot;My personal blog&quot;,\n\t&quot;_links&quot;: {\n\t\t&quot;articles&quot;: [\n\t\t\t{ &quot;href&quot;: &quot;\/blogs\/32\/articles\/some-article-slug&quot; },\n\t\t\t{ &quot;href&quot;: &quot;\/blogs\/32\/articles\/some-article-slug-blah&quot; }\n\t\t]\n\t},\n\t&quot;_embedded&quot;: {\n\t\t&quot;articles&quot;: [\n\t\t\t{\n\t\t\t\t&quot;slug&quot;: &quot;some-article-slug&quot;,\n\t\t\t\t&quot;title&quot;: &quot;Some article&quot;,\n\t\t\t\t&quot;published_at&quot;: &quot;2016-02-01 05:03:12&quot;,\n\t\t\t\t&quot;lead&quot;: &quot;Some article about some things&quot;,\n\t\t\t\t&quot;version&quot;: 1\n\t\t\t},\n\t\t\t{\n\t\t\t\t&quot;slug&quot;: &quot;some-article-slug-blah&quot;,\n\t\t\t\t&quot;title&quot;: &quot;Some article&quot;,\n\t\t\t\t&quot;published_at&quot;: &quot;2016-02-01 05:03:12&quot;,\n\t\t\t\t&quot;lead&quot;: &quot;Some article about some things&quot;,\n\t\t\t\t&quot;version&quot;: 7\n\t\t\t},\n\t\t]\n\t}\n}\n<\/code><\/pre>\n<p>If we want to show a list of articles on blog with id 32 we just need to <code>GET \/blogs\/32<\/code> and poof, the titles and leads are here, and if we need a full article, it's just one link away.\nThere's still one problem left. If I want to show last ten articles, why the hell should the API return them all? But fortunately this problem has been solved years ago. Let's simply use pagination (I called the link to the next page &quot;next&quot;, but that's just a convention):<\/p>\n<pre><code class=\"language-json\">{\n\t&quot;_links&quot;: {\n\t\t&quot;next&quot;: { &quot;href&quot;: &quot;\/blogs\/66?page=2&quot; }\n\t}\n}\n<\/code><\/pre>\n<p>Nice, problem solved. But years passed, the blog has hundrets of posts and our users want to search it. But wait, how do we define a link that contains some arbitrary input. But -- you guessed it -- JSON HAL got us covered. The feature is called <a href=\"https:\/\/tools.ietf.org\/html\/rfc6570\">URI template<\/a>. I'm not gonna go into too much detail (read the RFC if you really want to) about what the possible templates are, but here's a simple example:<\/p>\n<pre><code class=\"language-json\">{\n\t&quot;_links&quot;: {\n\t\t&quot;search&quot;: { &quot;href&quot;: &quot;\/blogs\/662\/articles{?query}&quot;, &quot;templated&quot;: true }\n\t}\n}\n<\/code><\/pre>\n<p>So now, the API client knows that to follow the &quot;search&quot; link they need to construct an URL to <code>\/blogs\/662\/articles?query=their+query<\/code> (the &quot;templated&quot; attribute just tells us that the link is a template).<\/p>\n<p>The JSON HAL specification is short and concise, but solves problems that many developers are facing in standardised way. I hope that some day, the web will be full of interlinked resources not only for humans, but also for machines.<\/p>\n"}